#!/usr/bin/env python
import numpy as np
import pandas as pd
import h5py
import argparse
import sys
import itertools
import lal
import os

def samples_from_prob_skymap(skymap, t0=None, nsamples=3200, plot_filepath=None, verbose=True):
    """
    Generate dtdphi samples soley from a probability skymap. Note that this uses only ra, dec information and assumes
    that the polarization angle \psi is uniform in [0, 2\pi] and the cosine of the inclination angle
    \cos \iota is uniform in [-1, 1]
    """
    import emcee
    # Again we *only* support emcee 2.2.1 where PTSampler is still included
    if emcee.__version__ != '2.2.1':
        raise ValueError("Only emcee 2.2.1 is supported. Please make sure that you are using this particular version of emcee.")
    import healpy as hp

    # Read t0 from skymap is t0 is not given in the option
    if t0 is None:
        if verbose:
            print >> sys.stderr, "Using the observation time in the skymap header as t0"
        import astropy.io.fits # Import astropy to read the header
        import lal.gpstime
        hdu = astropy.io.fits.open(skymap)
        t0 = float(lal.gpstime.str_to_gps(hdu[1].header['DATE-OBS']))

    hpx = hp.read_map(skymap, verbose=verbose)
    npix = len(hpx)
    nside = hp.npix2nside(npix)

    # Define the ln prior and ln likelihood for sampling
    def ln_prior(x):
        ra, sin_dec, psi, cos_iota = x
        if 0.0 <= ra < 2.0*np.pi and -1. <= sin_dec <= 1. and 0.0 <= psi < 2.0*np.pi and -1. <= cos_iota <= 1.:
            return 0.0
        else:
            return -np.inf

    def ln_likelihood(x):
        ra, sin_dec, psi, cos_iota = x
        # Effectively we have a uniform prior that RA \in [0, 2pi) and DEC \in [-pi/2, pi/2]
        if ln_prior(x) == 0.0:
            # Convert from sin_dec to dec
            dec = np.arcsin(sin_dec)
            # Then convert from dec to theta
            return np.log(hp.get_interp_val(hpx, -dec + np.pi/2., ra)) #FIXME Need to check the convention
        else:
            return -np.inf
    
    # Do the actual sampling here
    nwalkers = 32
    ndim = 4 # ra, sin_dec, psi, cos_iota
    ntemps = 8

    p0 = np.array([np.column_stack([2.0*np.pi*np.random.uniform(size=(nwalkers)), 2.0*np.random.uniform(size=(nwalkers)) - 1.0, 2.0*np.pi*np.random.uniform(size=(nwalkers)), 2.0*np.random.uniform(size=(nwalkers)) - 1.0]) for i in range(ntemps)]) # Initial position for the walker 
    
    # We use Parallel-Tempered MCMC sampler because the sky location posterior distribution is spiky!
    sampler = emcee.PTSampler(ntemps, nwalkers, ndim, ln_likelihood, ln_prior)
    # Initial burn-in stage
    if verbose:
        print >> sys.stderr, "Initial burn-in stage for PTMCMC"
    pos, ln_p, state = sampler.run_mcmc(p0, 100)

    # Reset the sampler
    sampler.reset()
    # Run the MCMC again
    if verbose:
        print >> sys.stderr, "Sampling {} samples from the probability skymap using PTMCMC".format(int(3200.*(nsamples/3200.)))
    p, log_prob, log_like = sampler.run_mcmc(pos, int(10000.0*(nsamples/3200.)), rstate0=state)
    if verbose:
        print >> sys.stderr, "Sampling completed"
    thin = 100
    ra_samples = sampler.chain[0,:,:,0].flatten()[::thin]
    dec_samples = np.arcsin(sampler.chain[0,:,:,1].flatten()[::thin])
    psi_samples = sampler.chain[0,:,:,2].flatten()[::thin]
    cos_iota_samples = sampler.chain[0,:,:,3].flatten()[::thin]
    t0_samples = np.ones(cos_iota_samples.shape) * t0

    if plot_filepath is not None:
        import matplotlib
        matplotlib.use("Agg")
        from matplotlib import pyplot as plt
        plt.rcParams["figure.dpi"] = 150
        import corner
        fig = corner.corner(np.transpose([ra_samples, dec_samples]), labels=[r"$\alpha$", r"$\delta$"])
        plt.savefig(plot_filepath)
        if verbose:
            print >> sys.stderr, "Corner plot of samples generated from probability skymap saved to " + plot_filepath

    return ra_samples, dec_samples, psi_samples, cos_iota_samples, t0_samples

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate samples of (RA, DEC) from a given skymap")
    parser.add_argument("--skymap", type=str, metavar="PATH", help="Path to the fits.gz skymap (usually generated by ligo.skymap)")
    parser.add_argument("--output", type=str, metavar="PATH", required=True, help="Path to the output dat file storing the samples")
    parser.add_argument("--plot", type=str, metavar="PATH", help="Generate a corner plot of samples generated and save it to the path pointed by --plot")
    parser.add_argument("--nsamples", type=int, metavar="INT", default=20000, help="Number of samples to generate")
    parser.add_argument("--t0", type=float, metavar="GPSTIME", help="GPS time of the observation. If ignored the time stored in the skymap will be used")
    parser.add_argument("--verbose", action="store_true", help="Be verbose")
    args = parser.parse_args()

    if not os.path.exists(args.output):
        ra_samples, dec_samples, _, _, _ = samples_from_prob_skymap(args.skymap, plot_filepath=args.plot, nsamples=args.nsamples, verbose=args.verbose)
        df = pd.DataFrame(data={'ra': ra_samples, 'dec':dec_samples})

        df.to_csv(args.output, sep='\t',header=True, index=False)
        if args.verbose:
            print >> sys.stderr, "Posterior samples generated from probability skymap saved to " + args.output
    else:
        if args.verbose:
            print >> sys.stderr, args.output + " already exists. Quitting now"

